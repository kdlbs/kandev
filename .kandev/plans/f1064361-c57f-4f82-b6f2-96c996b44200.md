# Implementation Plan: Session Artifacts (Task Plans)

## Overview
Implement a session artifacts system to store task plans in the database, with MCP tools for agents to create/read/update/delete plans, and a frontend UI to view and edit plans.

## Requirements Summary

Based on clarification questions:
1. **Artifact Type**: Focus on "plan" type only (extensible for future types)
2. **Storage**: Database only (metadata + content)
3. **Scope**: Task-scoped (plans shared across all sessions for a task)
4. **Frontend UI**: New tab in center panel (Chat/Changes/Plan)
5. **MCP Tools**: `create_task_plan`, `get_task_plan`, `update_task_plan`, `delete_task_plan`
6. **Planning Phase**: Update prompt to use MCP tool, remove file-based approach
7. **Plan Iteration Workflow**: Explicit iteration cycle:
   - Agent creates initial plan via MCP tool
   - User reviews and edits plan in UI
   - User saves edited plan
   - Agent retrieves updated plan and continues with implementation
   - Agent can update plan during execution if needed

## Data Model Design

### New Table: `task_plans`

```sql
CREATE TABLE task_plans (
    id TEXT PRIMARY KEY,
    task_id TEXT NOT NULL,
    title TEXT NOT NULL DEFAULT 'Plan',
    content TEXT NOT NULL DEFAULT '',
    created_by TEXT NOT NULL DEFAULT 'agent',  -- 'agent' or 'user'
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL,
    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE,
    UNIQUE(task_id)  -- One plan per task
);
```

### Go Model: `models.TaskPlan`

```go
type TaskPlan struct {
    ID        string    `json:"id"`
    TaskID    string    `json:"task_id"`
    Title     string    `json:"title"`
    Content   string    `json:"content"`
    CreatedBy string    `json:"created_by"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}
```

## Backend Implementation

### 1. Database Layer (`apps/backend/internal/task/repository/sqlite/`)

**New file: `plan.go`**
- `CreateTaskPlan(ctx, plan *models.TaskPlan) error`
- `GetTaskPlan(ctx, taskID string) (*models.TaskPlan, error)`
- `UpdateTaskPlan(ctx, plan *models.TaskPlan) error`
- `DeleteTaskPlan(ctx, taskID string) error`

**Update: `base.go`**
- Add `task_plans` table to schema in `initSchema()`

**Update: `repository.go` interface**
- Add plan methods to Repository interface

### 2. Service Layer (`apps/backend/internal/task/service/`)

**New file: `plan_service.go`**
- Business logic for plan operations
- Validation (task exists, content not empty, etc.)
- Event publishing for plan changes

### 3. Controller Layer (`apps/backend/internal/task/controller/`)

**Update: `task_controller.go`**
- Add plan-related methods that call service layer
- Handle DTOs for plan operations

### 4. DTO Layer (`apps/backend/internal/task/dto/`)

**New DTOs in existing files or new `plan_dto.go`:**
```go
type CreateTaskPlanRequest struct {
    TaskID  string `json:"task_id"`
    Title   string `json:"title"`
    Content string `json:"content"`
}

type UpdateTaskPlanRequest struct {
    TaskID  string `json:"task_id"`
    Title   string `json:"title"`
    Content string `json:"content"`
}

type TaskPlanResponse struct {
    ID        string `json:"id"`
    TaskID    string `json:"task_id"`
    Title     string `json:"title"`
    Content   string `json:"content"`
    CreatedBy string `json:"created_by"`
    CreatedAt string `json:"created_at"`
    UpdatedAt string `json:"updated_at"`
}
```

### 5. MCP Tools (`apps/backend/internal/agentctl/server/mcp/`)

**Update: `server.go` - registerTools()**
Add 4 new MCP tools:
- `create_task_plan` - Create a new plan for a task
  - Parameters: `task_id` (required), `content` (required), `title` (optional)
- `get_task_plan` - Get the plan for a task
  - Parameters: `task_id` (required)
- `update_task_plan` - Update existing plan
  - Parameters: `task_id` (required), `content` (required), `title` (optional)
- `delete_task_plan` - Delete a task's plan
  - Parameters: `task_id` (required)

**Update: `handlers.go`**
Implement handler functions for each MCP tool that forward to backend via WebSocket

### 6. MCP WebSocket Handlers (`apps/backend/internal/mcp/handlers/`)

**Update: `handlers.go`**
- Add action constants: `ActionMCPCreateTaskPlan`, `ActionMCPGetTaskPlan`, etc.
- Implement handlers that call task controller
- Register handlers in `RegisterHandlers()`

**Update: `apps/backend/pkg/websocket/actions.go`**
Add new action constants for plan operations

### 7. HTTP Handlers (Optional - for frontend direct access)

**Update: `apps/backend/internal/task/handlers/task_handlers.go`**
- Add HTTP endpoints: `POST /api/v1/tasks/:id/plan`, `GET /api/v1/tasks/:id/plan`, etc.
- Add WebSocket handlers for plan operations
- Register routes

### 8. Events & WebSocket Notifications

**Update: `apps/backend/internal/events/events.go`**
Add new event types:
- `TaskPlanCreated`
- `TaskPlanUpdated`
- `TaskPlanDeleted`

**Update: `apps/backend/pkg/websocket/actions.go`**
Add notification actions:
- `ActionTaskPlanCreated = "task.plan.created"`
- `ActionTaskPlanUpdated = "task.plan.updated"`
- `ActionTaskPlanDeleted = "task.plan.deleted"`

### 9. Update Planning Phase Prompt

**Update: `apps/backend/internal/workflow/repository/sqlite.go`**
Modify the planning step's `PromptPrefix` to instruct agents to use MCP tools and support iteration:

```
[PLANNING PHASE]
Analyze this task and create a detailed implementation plan.
Do NOT make any code changes yet - only analyze and plan.

Before creating the plan, ask the user clarifying questions if anything is unclear or ambiguous about the requirements. Use the ask_user_question_kandev tool to get answers before proceeding.

Create a plan that includes:
1. Understanding of the requirements
2. Files that need to be modified or created
3. Step-by-step implementation approach
4. Potential risks or considerations

IMPORTANT: Save your plan using the create_task_plan_kandev MCP tool with the task_id provided in the session context.
After saving the plan, STOP and wait for user review. The user will review your plan in the UI and may edit it.

When you resume (after user approval or edits):
1. Use get_task_plan_kandev to retrieve the latest version of the plan
2. Review any changes the user made
3. Acknowledge the plan and proceed with implementation
4. You can update the plan during implementation using update_task_plan_kandev if needed

Do not create any files during this phase - only use the MCP tool to save the plan.
```

**Note**: The agent needs access to both `task_id` and `session_id` in the session context. Verify these are available in the MCP tool environment.

### 10. Workflow Integration for Plan Iteration

**Update: Workflow Step Configuration**

The planning workflow step should be configured to support the iteration cycle:

```go
// Planning step configuration
{
    ID:           "planning",
    Name:         "Planning",
    StepType:     "planning",
    PlanMode:     true,
    AutoStart:    true,
    PromptPrefix: "[PLANNING PHASE]...", // As defined above
    OnComplete:   "review-plan",  // Transition to review step
    AllowManualMove: true,        // User can manually approve
}

// Review Plan step (optional - or use existing review step)
{
    ID:           "review-plan",
    Name:         "Review Plan",
    StepType:     "review",
    AutoStart:    false,  // Don't auto-start agent
    PromptPrefix: "Review the plan in the Plan tab. Edit if needed, then approve to continue.",
    OnComplete:   "implementation",
    AllowManualMove: true,
}
```

**Key Points:**
- Planning step creates plan and stops (agent completes turn)
- Task transitions to "review-plan" step automatically
- User reviews/edits plan in UI
- User manually approves (moves to "implementation" step)
- Implementation step starts with agent retrieving the plan

**Alternative Approach (Simpler):**
- Planning step creates plan and stops
- User reviews/edits in same "planning" step
- User clicks "Approve" button to transition to next step
- No separate "review-plan" step needed

### 11. Implementation Step Prompt Update

**Update: Implementation workflow step prompt**

The implementation step should instruct the agent to retrieve the plan:

```
[IMPLEMENTATION PHASE]
Before starting implementation, retrieve the task plan using get_task_plan_kandev.
Review the plan carefully, including any edits the user may have made.
Acknowledge the plan and any user modifications before proceeding.

Then implement the task following the plan step-by-step.
You can update the plan during implementation if you discover new requirements or need to adjust the approach.
```

This ensures the agent always starts with the latest version of the plan, including user edits.

## Frontend Implementation

### 1. TypeScript Types (`apps/web/lib/types/http.ts`)

Add new type:
```typescript
export type TaskPlan = {
  id: string;
  task_id: string;
  title: string;
  content: string;
  created_by: string;
  created_at: string;
  updated_at: string;
};
```

### 2. State Management (`apps/web/lib/state/slices/`)

**New slice or extend session slice: `task-plans-slice.ts`**
```typescript
export type TaskPlansState = {
  byTaskId: Record<string, TaskPlan | null>;
  loadingByTaskId: Record<string, boolean>;
  loadedByTaskId: Record<string, boolean>;
};

export type TaskPlansSlice = TaskPlansState & {
  setTaskPlan: (taskId: string, plan: TaskPlan | null) => void;
  setTaskPlanLoading: (taskId: string, loading: boolean) => void;
  updateTaskPlanContent: (taskId: string, content: string) => void;
};
```

**Update: `apps/web/lib/state/store.ts`**
- Add `taskPlans` to AppState
- Compose the new slice

### 3. API Client (`apps/web/lib/api/domains/`)

**New file: `plan-api.ts`**
```typescript
export async function getTaskPlan(taskId: string): Promise<TaskPlan | null>
export async function createTaskPlan(taskId: string, content: string, title?: string): Promise<TaskPlan>
export async function updateTaskPlan(taskId: string, content: string, title?: string): Promise<TaskPlan>
export async function deleteTaskPlan(taskId: string): Promise<void>
```

### 4. WebSocket Handlers (`apps/web/lib/ws/handlers/`)

**New file: `task-plans.ts`**
Handle WebSocket events:
- `task.plan.created` - Add plan to state
- `task.plan.updated` - Update plan in state
- `task.plan.deleted` - Remove plan from state

**Update: `apps/web/lib/ws/router.ts`**
Register plan handlers

### 5. React Hooks (`apps/web/hooks/domains/task/`)

**New file: `use-task-plan.ts`**
```typescript
export function useTaskPlan(taskId: string | null) {
  // Subscribe to plan updates via WebSocket
  // Fetch plan if not loaded
  // Return { plan, isLoading, error, updatePlan, deletePlan }
}
```

### 6. UI Components

**New component: `apps/web/components/task/task-plan-panel.tsx`**
- Markdown editor for plan content
- **Edit/Preview toggle** for better UX
- **Save button** (explicit save, not auto-save)
- **Discard changes button** to revert to saved version
- Show loading/saving states
- Display created/updated timestamps
- **Show who created/last updated** (agent vs user)
- Handle empty state (no plan yet - show "Agent will create plan during planning phase")
- **Visual indicator** when plan has unsaved changes
- **Confirmation dialog** before discarding changes

**Update: `apps/web/components/task/task-center-panel.tsx`**
- Add "Plan" tab alongside "Chat" and "Changes"
- Conditionally render TaskPlanPanel when Plan tab is active
- Pass taskId to TaskPlanPanel
- **Badge on Plan tab** if plan exists and has been updated recently

**Update: `apps/web/components/task/task-layout.tsx` (if needed)**
- Ensure Plan tab is visible in the tab list

### 7. Markdown Editor

Consider using existing libraries:
- `react-markdown` for rendering (with `rehype-sanitize` for security)
- `@uiw/react-md-editor` for editing (supports preview mode)
- Or simple textarea with separate preview panel
- Syntax highlighting for code blocks in preview

## Step-by-Step Implementation Approach

### Phase 1: Backend Foundation (Database & Models)
1. Add `task_plans` table to schema
2. Create `models.TaskPlan` struct
3. Implement repository methods (CRUD)
4. Add migration/schema update logic

### Phase 2: Backend Services & Controllers
5. Create plan service with business logic
6. Add controller methods
7. Create DTOs for requests/responses
8. Add validation logic

### Phase 3: MCP Tools
9. Register MCP tools in agentctl
10. Implement MCP handlers in agentctl
11. Implement backend WebSocket handlers for MCP
12. Add action constants
13. Test MCP tools with manual calls

### Phase 4: HTTP & WebSocket APIs
14. Add HTTP endpoints for plans
15. Add WebSocket request/response handlers
16. Implement event publishing
17. Add WebSocket notification handlers
18. Test API endpoints

### Phase 5: Update Planning Workflow
19. Update planning step prompt in workflow repository
20. Verify task_id and session_id are available to agents
21. Test planning phase with new MCP tool
22. **Ensure agent stops after creating plan** (waits for user review)

### Phase 6: Frontend State & API
23. Add TypeScript types
24. Create state slice for plans
25. Implement API client functions
26. Create WebSocket handlers
27. Register handlers in router

### Phase 7: Frontend UI
28. Create useTaskPlan hook
29. Build TaskPlanPanel component with edit/preview modes
30. Integrate Plan tab in task center panel
31. Add markdown editor/viewer
32. Implement explicit save functionality (not auto-save)
33. Add unsaved changes indicator and confirmation
34. Add loading and error states
35. Show creator/updater information

### Phase 8: Testing & Polish - Plan Iteration Workflow
36. **Test complete iteration cycle:**
    - Agent creates plan via MCP tool
    - Agent stops and waits
    - User opens Plan tab and reviews
    - User edits plan and saves
    - User approves/resumes session
    - Agent retrieves updated plan via get_task_plan_kandev
    - Agent acknowledges changes and proceeds
37. Test plan editing in frontend (unsaved changes, discard, etc.)
38. Test WebSocket real-time updates
39. Test edge cases (no plan, concurrent edits, etc.)
40. Add error handling and user feedback
41. Update documentation with iteration workflow

## Potential Risks & Considerations

### 1. Concurrent Edits
- **Risk**: Multiple users or sessions editing the same plan
- **Mitigation**:
  - Use optimistic updates with conflict detection
  - Show "last updated" timestamp
  - Consider adding version field for conflict resolution
  - WebSocket notifications keep all clients in sync

### 2. Large Plan Content
- **Risk**: Very large markdown plans may impact performance
- **Mitigation**:
  - Add content length validation (e.g., max 100KB)
  - Use debounced auto-save to reduce API calls
  - Consider pagination or lazy loading for very large plans

### 3. Agent Context Availability
- **Risk**: task_id and session_id may not be available in MCP tool context
- **Mitigation**:
  - Verify MCP server has access to session context
  - Pass IDs explicitly in tool parameters if needed
  - Update agent initialization to inject context

### 7. Agent Not Stopping After Plan Creation
- **Risk**: Agent may continue to implementation without waiting for user review
- **Mitigation**:
  - Update planning phase prompt to explicitly instruct agent to stop
  - Use workflow step transitions to enforce stopping point
  - Consider adding a "plan_created" flag that prevents auto-progression
  - Test with different agent models to ensure compliance

### 8. User Awareness of Plan Updates
- **Risk**: User may not notice when agent creates or updates a plan
- **Mitigation**:
  - Badge notification on Plan tab when plan is created/updated
  - Toast notification when plan changes
  - Highlight Plan tab when new plan is available
  - Show timestamp and "Updated by agent" indicator

### 4. Migration from File-Based Plans
- **Risk**: Existing `.kandev/plans/*.md` files won't be migrated
- **Mitigation**:
  - Add migration script to import existing plans to database
  - Or keep file-based plans as read-only reference
  - Document migration path for users

### 5. Markdown Rendering Security
- **Risk**: XSS vulnerabilities in markdown rendering
- **Mitigation**:
  - Use sanitized markdown renderer (react-markdown with rehype-sanitize)
  - Validate and sanitize content on backend
  - Don't allow arbitrary HTML in markdown

### 6. WebSocket Scalability
- **Risk**: Plan updates generating many WebSocket messages
- **Mitigation**:
  - Debounce plan updates on frontend
  - Only broadcast to task subscribers
  - Consider batching updates if needed

## Plan Iteration Workflow (Detailed)

This is the core user experience we're building:

### 1. Planning Phase - Agent Creates Plan
```
User: Creates task and starts agent in "Planning" workflow step
Agent:
  - Analyzes task requirements
  - May ask clarifying questions via ask_user_question_kandev
  - Creates detailed plan via create_task_plan_kandev(task_id, content)
  - Receives confirmation that plan was saved
  - STOPS and waits (does not proceed to implementation)

System:
  - Saves plan to database
  - Broadcasts task.plan.created event via WebSocket
  - Frontend receives notification and shows badge on Plan tab
```

### 2. User Review & Edit Phase
```
User:
  - Clicks on "Plan" tab (sees badge indicating new plan)
  - Reviews agent's plan in preview mode
  - Clicks "Edit" to switch to edit mode
  - Makes changes to the plan (add details, remove items, clarify steps)
  - Clicks "Save" button

System:
  - Saves updated plan to database (marks updated_by as 'user')
  - Broadcasts task.plan.updated event via WebSocket
  - Shows success message
```

### 3. User Approval & Agent Resume
```
User:
  - Reviews final plan
  - Clicks "Approve" or "Continue" button (existing workflow approval)
  - Or manually moves task to next workflow step

System:
  - Transitions task to next workflow step (e.g., "Implementation")
  - Resumes agent session or starts new session
```

### 4. Implementation Phase - Agent Retrieves Plan
```
Agent:
  - Session resumes in "Implementation" step
  - Calls get_task_plan_kandev(task_id) to retrieve latest plan
  - Reviews the plan (including any user edits)
  - Acknowledges: "I've reviewed the updated plan. I notice you [describe changes]. I'll proceed with..."
  - Begins implementation following the plan
  - Can call update_task_plan_kandev(task_id, content) if plan needs updates during implementation
```

### 5. Ongoing Iteration (Optional)
```
During implementation, if needed:
  - Agent updates plan: update_task_plan_kandev(task_id, updated_content)
  - User sees real-time update in Plan tab
  - User can edit again and save
  - Agent retrieves latest version before major steps
```

## Success Criteria

1. ✅ **Agent creates plan**: Agent uses `create_task_plan_kandev` MCP tool during planning phase
2. ✅ **Agent stops after planning**: Agent does not proceed to implementation until approved
3. ✅ **Plan stored in database**: Plans are persisted and associated with tasks
4. ✅ **Frontend displays plan**: Plan appears in dedicated "Plan" tab with badge notification
5. ✅ **User can edit plan**: Edit/Preview modes work, explicit save button, unsaved changes indicator
6. ✅ **User can save edits**: Saved plans update database and broadcast via WebSocket
7. ✅ **Agent retrieves updated plan**: Agent calls `get_task_plan_kandev` and acknowledges user changes
8. ✅ **Real-time updates**: WebSocket notifications keep all clients in sync
9. ✅ **Complete iteration cycle**: Full workflow from agent create → user edit → agent retrieve works
10. ✅ **MCP tools work correctly**: All CRUD operations (create, get, update, delete) function properly
11. ✅ **No file-based plans**: File-based approach removed from workflow prompts

## Future Enhancements (Out of Scope)

- Support for multiple artifact types (analysis, documentation, etc.)
- Plan versioning/history
- Plan templates
- Collaborative editing with conflict resolution
- Plan export to various formats
- Plan sharing across tasks
- Rich text editor instead of markdown
- Plan comments/annotations



