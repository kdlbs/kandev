package service

import (
	"context"
	"time"

	"github.com/google/uuid"
	"go.uber.org/zap"

	"github.com/kandev/kandev/internal/agentctl/types/streams"
	"github.com/kandev/kandev/internal/events"
	"github.com/kandev/kandev/internal/task/models"
)

// CreateMessage creates a new message on an agent session
func (s *Service) CreateMessage(ctx context.Context, req *CreateMessageRequest) (*models.Message, error) {
	session, err := s.sessions.GetTaskSession(ctx, req.TaskSessionID)
	if err != nil {
		return nil, err
	}

	authorType := models.MessageAuthorUser
	if req.AuthorType == "agent" {
		authorType = models.MessageAuthorAgent
	}

	messageType := models.MessageType(req.Type)
	if messageType == "" {
		messageType = models.MessageTypeMessage
	}

	taskID := req.TaskID
	if taskID == "" && session != nil {
		taskID = session.TaskID
	}

	// Ensure we have a turn ID - get active turn or start a new one
	turnID := req.TurnID
	if turnID == "" {
		turn, err := s.getOrStartTurn(ctx, req.TaskSessionID)
		if err != nil {
			s.logger.Warn("failed to get or start turn for message",
				zap.String("session_id", req.TaskSessionID),
				zap.Error(err))
			// Continue with empty turn ID - will fail on foreign key if turn is required
		} else if turn != nil {
			turnID = turn.ID
		}
	}

	message := &models.Message{
		ID:            uuid.New().String(),
		TaskSessionID: req.TaskSessionID,
		TaskID:        taskID,
		TurnID:        turnID,
		AuthorType:    authorType,
		AuthorID:      req.AuthorID,
		Content:       req.Content,
		Type:          messageType,
		Metadata:      req.Metadata,
		RequestsInput: req.RequestsInput,
		CreatedAt:     time.Now().UTC(),
	}

	if err := s.messages.CreateMessage(ctx, message); err != nil {
		s.logger.Error("failed to create message", zap.Error(err))
		return nil, err
	}

	// Publish message.added event
	s.publishMessageEvent(ctx, events.MessageAdded, message)

	s.logger.Info("message created",
		zap.String("message_id", message.ID),
		zap.String("session_id", message.TaskSessionID),
		zap.String("author_type", string(message.AuthorType)))

	return message, nil
}

// CreateMessageWithID creates a new message with a pre-generated ID.
// This is used for streaming messages where the ID is generated by the caller.
// It includes retry logic to handle transient database errors and ensure
// message chunks are not lost during streaming.
func (s *Service) CreateMessageWithID(ctx context.Context, id string, req *CreateMessageRequest) (*models.Message, error) {
	const maxRetries = 5
	const retryDelay = 50 * time.Millisecond

	session, err := s.getSessionWithRetry(ctx, req.TaskSessionID, id, maxRetries, retryDelay)
	if err != nil {
		return nil, err
	}

	message := s.buildMessage(ctx, id, req, session)

	if err := s.createMessageWithRetry(ctx, message, maxRetries, retryDelay); err != nil {
		return nil, err
	}

	// Publish message.added event
	s.publishMessageEvent(ctx, events.MessageAdded, message)

	s.logger.Info("message created with ID",
		zap.String("message_id", message.ID),
		zap.String("session_id", message.TaskSessionID),
		zap.String("author_type", string(message.AuthorType)))

	return message, nil
}

// getSessionWithRetry fetches a session, retrying on transient errors caused by out-of-order events.
func (s *Service) getSessionWithRetry(ctx context.Context, sessionID, messageID string, maxRetries int, retryDelay time.Duration) (*models.TaskSession, error) {
	var session *models.TaskSession
	var err error
	for attempt := 0; attempt < maxRetries; attempt++ {
		session, err = s.sessions.GetTaskSession(ctx, sessionID)
		if err == nil {
			return session, nil
		}
		if ctx.Err() != nil {
			return nil, ctx.Err()
		}
		if attempt < maxRetries-1 {
			s.logger.Debug("session not found for message create, retrying",
				zap.String("session_id", sessionID),
				zap.String("message_id", messageID),
				zap.Int("attempt", attempt+1),
				zap.Int("max_retries", maxRetries))
			time.Sleep(retryDelay)
		}
	}
	s.logger.Warn("session not found for message create after retries",
		zap.String("session_id", sessionID),
		zap.String("message_id", messageID),
		zap.Int("retries", maxRetries),
		zap.Error(err))
	return nil, err
}

// buildMessage constructs a Message model from a CreateMessageRequest and resolved session.
func (s *Service) buildMessage(ctx context.Context, id string, req *CreateMessageRequest, session *models.TaskSession) *models.Message {
	authorType := models.MessageAuthorUser
	if req.AuthorType == "agent" {
		authorType = models.MessageAuthorAgent
	}

	messageType := models.MessageType(req.Type)
	if messageType == "" {
		messageType = models.MessageTypeMessage
	}

	taskID := req.TaskID
	if taskID == "" && session != nil {
		taskID = session.TaskID
	}

	turnID := req.TurnID
	if turnID == "" {
		if turn, err := s.getOrStartTurn(ctx, req.TaskSessionID); err != nil {
			s.logger.Warn("failed to get or start turn for streaming message",
				zap.String("session_id", req.TaskSessionID),
				zap.Error(err))
		} else if turn != nil {
			turnID = turn.ID
		}
	}

	return &models.Message{
		ID:            id,
		TaskSessionID: req.TaskSessionID,
		TaskID:        taskID,
		TurnID:        turnID,
		AuthorType:    authorType,
		AuthorID:      req.AuthorID,
		Content:       req.Content,
		Type:          messageType,
		Metadata:      req.Metadata,
		RequestsInput: req.RequestsInput,
		CreatedAt:     time.Now().UTC(),
	}
}

// createMessageWithRetry persists a message with retry logic for transient DB errors.
func (s *Service) createMessageWithRetry(ctx context.Context, message *models.Message, maxRetries int, retryDelay time.Duration) error {
	var err error
	for attempt := 0; attempt < maxRetries; attempt++ {
		err = s.messages.CreateMessage(ctx, message)
		if err == nil {
			return nil
		}
		if ctx.Err() != nil {
			return ctx.Err()
		}
		if attempt < maxRetries-1 {
			s.logger.Debug("failed to create message, retrying",
				zap.String("message_id", message.ID),
				zap.Int("attempt", attempt+1),
				zap.Int("max_retries", maxRetries),
				zap.Error(err))
			time.Sleep(retryDelay)
		}
	}
	s.logger.Error("failed to create message with ID after retries",
		zap.String("id", message.ID),
		zap.Int("retries", maxRetries),
		zap.Error(err))
	return err
}

// GetMessage retrieves a message by ID
func (s *Service) GetMessage(ctx context.Context, id string) (*models.Message, error) {
	return s.messages.GetMessage(ctx, id)
}

// ListMessages returns all messages for a session.
func (s *Service) ListMessages(ctx context.Context, sessionID string) ([]*models.Message, error) {
	return s.messages.ListMessages(ctx, sessionID)
}

// ListMessagesPaginated returns messages for a session with pagination options.
func (s *Service) ListMessagesPaginated(ctx context.Context, req ListMessagesRequest) ([]*models.Message, bool, error) {
	limit := req.Limit
	if limit <= 0 && (req.Before != "" || req.After != "") {
		limit = DefaultMessagesPageSize
	}
	if limit > MaxMessagesPageSize {
		limit = MaxMessagesPageSize
	}
	return s.messages.ListMessagesPaginated(ctx, req.TaskSessionID, models.ListMessagesOptions{
		Limit:  limit,
		Before: req.Before,
		After:  req.After,
		Sort:   req.Sort,
	})
}

// DeleteMessage deletes a message
func (s *Service) DeleteMessage(ctx context.Context, id string) error {
	if err := s.messages.DeleteMessage(ctx, id); err != nil {
		s.logger.Error("failed to delete message", zap.String("message_id", id), zap.Error(err))
		return err
	}

	s.logger.Info("message deleted", zap.String("message_id", id))
	return nil
}

// UpdateMessage updates an existing message and publishes an event.
func (s *Service) UpdateMessage(ctx context.Context, message *models.Message) error {
	if err := s.messages.UpdateMessage(ctx, message); err != nil {
		s.logger.Error("failed to update message",
			zap.String("message_id", message.ID),
			zap.Error(err))
		return err
	}

	// Publish message.updated event for real-time streaming
	s.publishMessageEvent(ctx, events.MessageUpdated, message)

	return nil
}

// AppendMessageContent appends additional content to an existing message.
// This is used for streaming agent responses where content arrives incrementally.
//
// When a StreamingBuffer is configured, content is accumulated in memory and
// flushed to the database periodically (every ~500ms) instead of per-chunk.
// The WS event is always published immediately from the in-memory state.
func (s *Service) AppendMessageContent(ctx context.Context, messageID, additionalContent string) error {
	if s.streamBuf != nil {
		return s.appendMessageContentBuffered(ctx, messageID, additionalContent)
	}
	return s.appendMessageContentDirect(ctx, messageID, additionalContent)
}

func (s *Service) appendMessageContentBuffered(ctx context.Context, messageID, additionalContent string) error {
	message, err := s.streamBuf.Append(ctx, messageID, additionalContent)
	if err != nil {
		s.logger.Warn("message not found for buffered append",
			zap.String("message_id", messageID),
			zap.Error(err))
		return err
	}

	s.publishMessageEvent(ctx, events.MessageUpdated, message)

	s.logger.Debug("message content appended (buffered)",
		zap.String("message_id", messageID),
		zap.Int("appended_length", len(additionalContent)),
		zap.Int("total_length", len(message.Content)))

	return nil
}

func (s *Service) appendMessageContentDirect(ctx context.Context, messageID, additionalContent string) error {
	message, err := s.messages.GetMessage(ctx, messageID)
	if err != nil {
		s.logger.Warn("message not found for append",
			zap.String("message_id", messageID),
			zap.Error(err))
		return err
	}

	message.Content += additionalContent

	if err := s.messages.UpdateMessage(ctx, message); err != nil {
		s.logger.Error("failed to append message content",
			zap.String("message_id", messageID),
			zap.Error(err))
		return err
	}

	s.publishMessageEvent(ctx, events.MessageUpdated, message)

	s.logger.Debug("message content appended",
		zap.String("message_id", messageID),
		zap.Int("appended_length", len(additionalContent)),
		zap.Int("total_length", len(message.Content)))

	return nil
}

// AppendThinkingContent appends additional thinking content to an existing thinking message.
// This updates the metadata.thinking field for streaming agent reasoning.
//
// When a StreamingBuffer is configured, thinking content is accumulated in
// memory and flushed periodically instead of per-chunk.
func (s *Service) AppendThinkingContent(ctx context.Context, messageID, additionalContent string) error {
	if s.streamBuf != nil {
		return s.appendThinkingContentBuffered(ctx, messageID, additionalContent)
	}
	return s.appendThinkingContentDirect(ctx, messageID, additionalContent)
}

func (s *Service) appendThinkingContentBuffered(ctx context.Context, messageID, additionalContent string) error {
	message, err := s.streamBuf.AppendThinking(ctx, messageID, additionalContent)
	if err != nil {
		s.logger.Warn("thinking message not found for buffered append",
			zap.String("message_id", messageID),
			zap.Error(err))
		return err
	}

	s.publishMessageEvent(ctx, events.MessageUpdated, message)

	s.logger.Debug("thinking content appended (buffered)",
		zap.String("message_id", messageID),
		zap.Int("appended_length", len(additionalContent)))

	return nil
}

func (s *Service) appendThinkingContentDirect(ctx context.Context, messageID, additionalContent string) error {
	message, err := s.messages.GetMessage(ctx, messageID)
	if err != nil {
		s.logger.Warn("thinking message not found for append",
			zap.String("message_id", messageID),
			zap.Error(err))
		return err
	}

	if message.Metadata == nil {
		message.Metadata = make(map[string]interface{})
	}

	existingThinking := ""
	if existing, ok := message.Metadata["thinking"].(string); ok {
		existingThinking = existing
	}
	message.Metadata["thinking"] = existingThinking + additionalContent

	if err := s.messages.UpdateMessage(ctx, message); err != nil {
		s.logger.Error("failed to append thinking content",
			zap.String("message_id", messageID),
			zap.Error(err))
		return err
	}

	s.publishMessageEvent(ctx, events.MessageUpdated, message)

	s.logger.Debug("thinking content appended",
		zap.String("message_id", messageID),
		zap.Int("appended_length", len(additionalContent)))

	return nil
}

// UpdateToolCallMessage updates a tool call message's status, optionally title and normalized data.
// It includes retry logic to handle race conditions where the complete event
// may arrive before the message has been created by the start event.
// If the message is not found after retries and taskID/turnID/msgType are provided, it creates the message.
// The normalized parameter contains typed tool payload data that gets added to metadata.
func (s *Service) UpdateToolCallMessage(ctx context.Context, sessionID, toolCallID, status, result, title string, normalized *streams.NormalizedPayload) error {
	return s.UpdateToolCallMessageWithCreate(ctx, sessionID, toolCallID, "", status, result, title, normalized, "", "", "")
}

// UpdateToolCallMessageWithCreate is like UpdateToolCallMessage but can create the message if not found.
// If taskID, turnID, and msgType are provided, the message will be created if it doesn't exist.
// parentToolCallID is used for subagent nesting (empty for top-level).
func (s *Service) UpdateToolCallMessageWithCreate(ctx context.Context, sessionID, toolCallID, parentToolCallID, status, result, title string, normalized *streams.NormalizedPayload, taskID, turnID, msgType string) error {
	const maxRetries = 5
	const retryDelay = 100 * time.Millisecond

	message, err := s.getToolCallMessageWithRetry(ctx, sessionID, toolCallID, maxRetries, retryDelay)

	// If message not found and we have enough info to create it, do so
	if err != nil && taskID != "" && msgType != "" {
		return s.createToolCallMessageFallback(ctx, sessionID, toolCallID, parentToolCallID, status, title, turnID, taskID, msgType, normalized)
	}

	if err != nil {
		s.logger.Warn("tool call message not found for update after retries",
			zap.String("session_id", sessionID),
			zap.String("tool_call_id", toolCallID),
			zap.Int("retries", maxRetries),
			zap.Error(err))
		return err
	}

	s.applyToolCallMessageUpdate(message, status, result, title, normalized)

	if err := s.messages.UpdateMessage(ctx, message); err != nil {
		s.logger.Error("failed to update tool call message",
			zap.String("message_id", message.ID),
			zap.String("tool_call_id", toolCallID),
			zap.Error(err))
		return err
	}

	// Publish message.updated event
	s.publishMessageEvent(ctx, events.MessageUpdated, message)

	s.logger.Info("tool call message updated",
		zap.String("message_id", message.ID),
		zap.String("tool_call_id", toolCallID),
		zap.String("status", status))

	return nil
}

// getToolCallMessageWithRetry fetches a tool call message with retry logic for race conditions.
func (s *Service) getToolCallMessageWithRetry(ctx context.Context, sessionID, toolCallID string, maxRetries int, retryDelay time.Duration) (*models.Message, error) {
	var message *models.Message
	var err error
	for attempt := 0; attempt < maxRetries; attempt++ {
		message, err = s.messages.GetMessageByToolCallID(ctx, sessionID, toolCallID)
		if err == nil {
			return message, nil
		}
		if ctx.Err() != nil {
			return nil, ctx.Err()
		}
		if attempt < maxRetries-1 {
			s.logger.Debug("tool call message not found, retrying",
				zap.String("session_id", sessionID),
				zap.String("tool_call_id", toolCallID),
				zap.Int("attempt", attempt+1),
				zap.Int("max_retries", maxRetries))
			time.Sleep(retryDelay)
		}
	}
	return nil, err
}

// createToolCallMessageFallback creates a tool call message when it cannot be found via GetMessageByToolCallID.
func (s *Service) createToolCallMessageFallback(ctx context.Context, sessionID, toolCallID, parentToolCallID, status, title, turnID, taskID, msgType string, normalized *streams.NormalizedPayload) error {
	s.logger.Info("tool call message not found, creating it",
		zap.String("session_id", sessionID),
		zap.String("tool_call_id", toolCallID),
		zap.String("task_id", taskID),
		zap.String("msg_type", msgType))

	metadata := map[string]interface{}{
		"tool_call_id": toolCallID,
		"title":        title,
		"status":       status,
	}
	if parentToolCallID != "" {
		metadata["parent_tool_call_id"] = parentToolCallID
	}
	if normalized != nil {
		metadata["normalized"] = normalized
	}

	msg, createErr := s.CreateMessage(ctx, &CreateMessageRequest{
		TaskSessionID: sessionID,
		TaskID:        taskID,
		TurnID:        turnID,
		Content:       title,
		AuthorType:    "agent",
		Type:          msgType,
		Metadata:      metadata,
	})
	if createErr != nil {
		s.logger.Error("failed to create tool call message as fallback",
			zap.String("session_id", sessionID),
			zap.String("tool_call_id", toolCallID),
			zap.Error(createErr))
		return createErr
	}

	s.logger.Info("created tool call message as fallback",
		zap.String("message_id", msg.ID),
		zap.String("tool_call_id", toolCallID),
		zap.String("status", status))
	return nil
}

// applyToolCallMessageUpdate applies status, result, normalized data, and title to a tool call message.
func (s *Service) applyToolCallMessageUpdate(message *models.Message, status, result, title string, normalized *streams.NormalizedPayload) {
	if message.Metadata == nil {
		message.Metadata = make(map[string]interface{})
	}
	message.Metadata["status"] = status
	if result != "" {
		message.Metadata["result"] = result
	}

	if normalized != nil {
		message.Metadata["normalized"] = normalized
		// Update message type if the normalized kind changed
		// This handles cases like Read on a directory converting to code_search
		newMsgType := models.MessageType(normalized.Kind().ToMessageType())
		if newMsgType != message.Type {
			s.logger.Debug("updating message type based on normalized kind",
				zap.String("message_id", message.ID),
				zap.String("old_type", string(message.Type)),
				zap.String("new_type", string(newMsgType)),
				zap.String("normalized_kind", string(normalized.Kind())))
			message.Type = newMsgType
		}
	}

	// Update title/content if provided and different from current
	if title != "" && title != message.Content {
		message.Content = title
		message.Metadata["title"] = title
	}
}

// UpdatePermissionMessage updates a permission request message's status.
// It includes retry logic to handle race conditions.
func (s *Service) UpdatePermissionMessage(ctx context.Context, sessionID, pendingID, status string) error {
	const maxRetries = 5
	const retryDelay = 100 * time.Millisecond

	var message *models.Message
	var err error

	// Retry loop to handle race condition
	for attempt := 0; attempt < maxRetries; attempt++ {
		message, err = s.messages.GetMessageByPendingID(ctx, sessionID, pendingID)
		if err == nil {
			break
		}

		if ctx.Err() != nil {
			return ctx.Err()
		}

		if attempt < maxRetries-1 {
			s.logger.Debug("permission message not found, retrying",
				zap.String("session_id", sessionID),
				zap.String("pending_id", pendingID),
				zap.Int("attempt", attempt+1),
				zap.Int("max_retries", maxRetries))
			time.Sleep(retryDelay)
		}
	}

	if err != nil {
		s.logger.Warn("permission message not found for update after retries",
			zap.String("session_id", sessionID),
			zap.String("pending_id", pendingID),
			zap.Int("retries", maxRetries),
			zap.Error(err))
		return err
	}

	if message.Metadata == nil {
		message.Metadata = make(map[string]interface{})
	}
	message.Metadata["status"] = status

	if err := s.messages.UpdateMessage(ctx, message); err != nil {
		s.logger.Error("failed to update permission message",
			zap.String("message_id", message.ID),
			zap.String("pending_id", pendingID),
			zap.Error(err))
		return err
	}

	// Publish message.updated event
	s.publishMessageEvent(ctx, events.MessageUpdated, message)

	// When a permission expires, also mark the related tool call as cancelled
	// so the UI no longer shows a loading spinner on the tool call.
	if status == "expired" {
		if toolCallID, ok := message.Metadata["tool_call_id"].(string); ok && toolCallID != "" {
			if err := s.UpdateToolCallMessage(ctx, sessionID, toolCallID, "error", "", "", nil); err != nil {
				s.logger.Warn("failed to cancel related tool call message",
					zap.String("tool_call_id", toolCallID),
					zap.String("pending_id", pendingID),
					zap.Error(err))
			}
		}
	}

	s.logger.Info("permission message updated",
		zap.String("message_id", message.ID),
		zap.String("pending_id", pendingID),
		zap.String("status", status))

	return nil
}

// UpdateClarificationMessage updates a clarification request message's status and response.
// It includes retry logic to handle race conditions.
// The answers parameter should be a slice of answer objects with question_id, selected_options, and custom_text.
func (s *Service) UpdateClarificationMessage(ctx context.Context, sessionID, pendingID, status string, answers interface{}) error {
	const maxRetries = 5
	const retryDelay = 100 * time.Millisecond

	var message *models.Message
	var err error

	// Retry loop to handle race condition
	for attempt := 0; attempt < maxRetries; attempt++ {
		message, err = s.messages.GetMessageByPendingID(ctx, sessionID, pendingID)
		if err == nil {
			break
		}

		if ctx.Err() != nil {
			return ctx.Err()
		}

		if attempt < maxRetries-1 {
			s.logger.Debug("clarification message not found, retrying",
				zap.String("session_id", sessionID),
				zap.String("pending_id", pendingID),
				zap.Int("attempt", attempt+1),
				zap.Int("max_retries", maxRetries))
			time.Sleep(retryDelay)
		}
	}

	if err != nil {
		s.logger.Warn("clarification message not found for update after retries",
			zap.String("session_id", sessionID),
			zap.String("pending_id", pendingID),
			zap.Int("retries", maxRetries),
			zap.Error(err))
		return err
	}

	if message.Metadata == nil {
		message.Metadata = make(map[string]interface{})
	}
	message.Metadata["status"] = status
	if answers != nil {
		message.Metadata["response"] = answers
	}

	if err := s.messages.UpdateMessage(ctx, message); err != nil {
		s.logger.Error("failed to update clarification message",
			zap.String("message_id", message.ID),
			zap.String("pending_id", pendingID),
			zap.Error(err))
		return err
	}

	// Publish message.updated event
	s.publishMessageEvent(ctx, events.MessageUpdated, message)

	s.logger.Info("clarification message updated",
		zap.String("message_id", message.ID),
		zap.String("pending_id", pendingID),
		zap.String("status", status))

	return nil
}

// FinalizeStreamingMessages force-flushes all buffered streaming messages
// for a given session. Call this on turn complete to ensure all content is
// persisted before the turn is marked complete.
func (s *Service) FinalizeStreamingMessages(ctx context.Context, sessionID string) {
	if s.streamBuf != nil {
		s.streamBuf.FinalizeAll(ctx, sessionID)
	}
}

// CreateLogMessage creates a log message via the batcher (if configured) or
// falls back to the normal CreateMessage path. The WS event is published
// immediately regardless of whether the DB write is batched.
func (s *Service) CreateLogMessage(ctx context.Context, req *CreateMessageRequest) (*models.Message, error) {
	if s.logBatcher == nil {
		return s.CreateMessage(ctx, req)
	}

	session, err := s.sessions.GetTaskSession(ctx, req.TaskSessionID)
	if err != nil {
		return nil, err
	}

	message := s.buildMessage(ctx, uuid.New().String(), req, session)

	s.logBatcher.Add(message)

	// Publish WS event immediately so the frontend shows the log in real-time
	s.publishMessageEvent(ctx, events.MessageAdded, message)

	s.logger.Debug("log message batched",
		zap.String("message_id", message.ID),
		zap.String("session_id", message.TaskSessionID))

	return message, nil
}
